// レポート生成サービス
// PDFKit + Chart.js を使用

const PDFDocument = require('pdfkit');
const { createCanvas } = require('canvas');
const { Chart } = require('chart.js/auto');
const fs = require('fs');
const path = require('path');
const { Pool } = require('pg');

// PostgreSQL接続
const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'webpush',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'password',
});

class ReportService {
  constructor() {
    this.reportsDir = path.join(__dirname, 'reports');
    this.assetsDir = path.join(__dirname, 'assets');
    this.templatesDir = path.join(__dirname, 'templates');
    
    // ディレクトリ作成
    [this.reportsDir, this.assetsDir, this.templatesDir].forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  // カスタムテンプレート設定を取得
  async getCustomTemplate(siteId) {
    const client = await pool.connect();
    try {
      const result = await client.query(
        'SELECT report_template FROM sites WHERE id = $1',
        [siteId]
      );
      
      if (result.rows.length > 0 && result.rows[0].report_template) {
        return JSON.parse(result.rows[0].report_template);
      }
      
      // デフォルトテンプレート
      return this.getDefaultTemplate();
    } catch (error) {
      console.error('Get custom template error:', error);
      return this.getDefaultTemplate();
    } finally {
      client.release();
    }
  }

  // デフォルトテンプレート
  getDefaultTemplate() {
    return {
      primaryColor: '#667eea',
      secondaryColor: '#764ba2',
      accentColor: '#48bb78',
      textColor: '#333333',
      lightBgColor: '#f7fafc',
      logoUrl: null,
      companyName: 'WebPush Pro',
      footer: 'Generated by WebPush Pro',
      showLogo: true,
      showWatermark: true
    };
  }

  // ダッシュボードレポート生成（テンプレート対応版）
  async generateDashboardReport(siteId, startDate, endDate, customTemplate = null) {
    const client = await pool.connect();
    
    try {
      // サイト情報取得
      const siteResult = await client.query(
        'SELECT * FROM sites WHERE id = $1',
        [siteId]
      );
      
      if (siteResult.rows.length === 0) {
        throw new Error('Site not found');
      }
      
      const site = siteResult.rows[0];

      // カスタムテンプレート取得
      const template = customTemplate || await this.getCustomTemplate(siteId);

      // 統計データ取得
      const stats = await this.getStatistics(client, siteId, startDate, endDate);
      
      // PDFファイル名
      const filename = `report_${siteId}_${Date.now()}.pdf`;
      const filepath = path.join(this.reportsDir, filename);

      // PDF生成（テンプレート適用）
      await this.createPDF(filepath, site, stats, startDate, endDate, template);

      return {
        filename,
        filepath,
        url: `/api/reports/${filename}`
      };
    } catch (error) {
      console.error('Generate report error:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  // 統計データ取得
  async getStatistics(client, siteId, startDate, endDate) {
    // 基本統計
    const overviewResult = await client.query(`
      SELECT 
        COUNT(DISTINCT s.id) FILTER (WHERE s.is_active = true) as active_subscribers,
        COUNT(DISTINCT s.id) as total_subscribers,
        COUNT(DISTINCT c.id) as total_campaigns,
        SUM(CASE WHEN d.status = 'sent' THEN 1 ELSE 0 END) as total_sent,
        SUM(CASE WHEN d.status = 'clicked' THEN 1 ELSE 0 END) as total_clicks,
        ROUND(
          CASE 
            WHEN SUM(CASE WHEN d.status = 'sent' THEN 1 ELSE 0 END) > 0 
            THEN (SUM(CASE WHEN d.status = 'clicked' THEN 1 ELSE 0 END)::decimal / 
                  SUM(CASE WHEN d.status = 'sent' THEN 1 ELSE 0 END)) * 100
            ELSE 0
          END, 2
        ) as avg_ctr
      FROM sites site
      LEFT JOIN subscribers s ON site.id = s.site_id
      LEFT JOIN campaigns c ON site.id = c.site_id AND c.created_at BETWEEN $2 AND $3
      LEFT JOIN deliveries d ON c.id = d.campaign_id
      WHERE site.id = $1
    `, [siteId, startDate, endDate]);

    // デバイス別統計
    const deviceResult = await client.query(`
      SELECT 
        device_type,
        COUNT(*) as count
      FROM subscribers
      WHERE site_id = $1 AND is_active = true
      GROUP BY device_type
      ORDER BY count DESC
    `, [siteId]);

    // ブラウザ別統計
    const browserResult = await client.query(`
      SELECT 
        browser,
        COUNT(*) as count
      FROM subscribers
      WHERE site_id = $1 AND is_active = true
      GROUP BY browser
      ORDER BY count DESC
    `, [siteId]);

    // 日別トレンド
    const trendResult = await client.query(`
      SELECT 
        DATE(sent_at) as date,
        COUNT(*) FILTER (WHERE status = 'sent') as sent,
        COUNT(*) FILTER (WHERE status = 'clicked') as clicked,
        ROUND(
          CASE 
            WHEN COUNT(*) FILTER (WHERE status = 'sent') > 0
            THEN (COUNT(*) FILTER (WHERE status = 'clicked')::decimal / 
                  COUNT(*) FILTER (WHERE status = 'sent')) * 100
            ELSE 0
          END, 2
        ) as ctr
      FROM deliveries d
      INNER JOIN campaigns c ON d.campaign_id = c.id
      WHERE c.site_id = $1 
        AND sent_at BETWEEN $2 AND $3
      GROUP BY DATE(sent_at)
      ORDER BY date
    `, [siteId, startDate, endDate]);

    // トップキャンペーン
    const topCampaignsResult = await client.query(`
      SELECT 
        c.name,
        c.created_at,
        COUNT(*) FILTER (WHERE d.status = 'sent') as sent,
        COUNT(*) FILTER (WHERE d.status = 'clicked') as clicked,
        ROUND(
          CASE 
            WHEN COUNT(*) FILTER (WHERE d.status = 'sent') > 0
            THEN (COUNT(*) FILTER (WHERE d.status = 'clicked')::decimal / 
                  COUNT(*) FILTER (WHERE d.status = 'sent')) * 100
            ELSE 0
          END, 2
        ) as ctr
      FROM campaigns c
      LEFT JOIN deliveries d ON c.id = d.campaign_id
      WHERE c.site_id = $1 
        AND c.created_at BETWEEN $2 AND $3
      GROUP BY c.id, c.name, c.created_at
      ORDER BY ctr DESC
      LIMIT 10
    `, [siteId, startDate, endDate]);

    // 購読者増加トレンド
    const subscriberGrowthResult = await client.query(`
      SELECT 
        DATE(subscribed_at) as date,
        COUNT(*) as new_subscribers
      FROM subscribers
      WHERE site_id = $1 
        AND subscribed_at BETWEEN $2 AND $3
      GROUP BY DATE(subscribed_at)
      ORDER BY date
    `, [siteId, startDate, endDate]);

    return {
      overview: overviewResult.rows[0],
      devices: deviceResult.rows,
      browsers: browserResult.rows,
      trend: trendResult.rows,
      topCampaigns: topCampaignsResult.rows,
      subscriberGrowth: subscriberGrowthResult.rows
    };
  }

  // PDF作成
  async createPDF(filepath, site, stats, startDate, endDate, template) {
    return new Promise(async (resolve, reject) => {
      try {
        const doc = new PDFDocument({ 
          size: 'A4',
          margin: 50,
          info: {
            Title: `Webプッシュ通知レポート - ${site.name}`,
            Author: 'WebPush Pro',
            Subject: 'キャンペーンレポート',
            Keywords: 'webpush, report, analytics'
          }
        });

        const stream = fs.createWriteStream(filepath);
        doc.pipe(stream);

        // 日本語フォント設定（Noto Sans JPなど）
        // const fontPath = path.join(__dirname, 'fonts', 'NotoSansJP-Regular.ttf');
        // if (fs.existsSync(fontPath)) {
        //   doc.registerFont('NotoSans', fontPath);
        //   doc.font('NotoSans');
        // }

        // ヘッダー
        this.addHeader(doc, site, startDate, endDate, template);

        // サマリーセクション
        this.addSummarySection(doc, stats.overview, template);

        // グラフセクション
        await this.addChartsSection(doc, stats, template);

        // トップキャンペーンテーブル
        this.addTopCampaignsTable(doc, stats.topCampaigns, template);

        // デバイス・ブラウザ統計
        this.addDeviceBrowserStats(doc, stats.devices, stats.browsers, template);

        // フッター
        this.addFooter(doc, template);

        doc.end();

        stream.on('finish', () => {
          console.log(`Report generated: ${filepath}`);
          resolve(filepath);
        });

        stream.on('error', reject);
      } catch (error) {
        reject(error);
      }
    });
  }

  // ヘッダー追加
  addHeader(doc, site, startDate, endDate, template) {
    const { primaryColor, logoUrl, showLogo, companyName } = template;

    // ロゴ表示
    if (showLogo && logoUrl) {
      const logoPath = path.join(this.assetsDir, 'logo.png');
      if (fs.existsSync(logoPath)) {
        try {
          doc.image(logoPath, 50, 50, { width: 80 });
        } catch (error) {
          console.error('Logo image error:', error);
        }
      }
    }

    // タイトル
    const titleX = showLogo && logoUrl ? 140 : 50;
    doc.fontSize(24)
       .fillColor(primaryColor)
       .text('Web Push Report', titleX, 50);

    // サイト名
    doc.fontSize(16)
       .fillColor(template.textColor)
       .text(site.name, titleX, 85);

    // 期間
    doc.fontSize(10)
       .fillColor('#666')
       .text(`Period: ${startDate} - ${endDate}`, titleX, 110);

    // 生成日時
    doc.fontSize(10)
       .fillColor('#999')
       .text(`Generated: ${new Date().toLocaleString('ja-JP')}`, titleX, 125);

    // 区切り線
    doc.moveTo(50, 145)
       .lineTo(545, 145)
       .stroke('#ddd');

    doc.moveDown(3);
  }

  // サマリーセクション
  addSummarySection(doc, overview, template) {
    const y = 170;
    
    doc.fontSize(14)
       .fillColor(template.textColor)
       .text('Overview', 50, y);

    // 4つのKPIボックス（カスタムカラー適用）
    const boxes = [
      { label: 'Active Subscribers', value: overview.active_subscribers?.toLocaleString() || '0', color: template.primaryColor },
      { label: 'Total Campaigns', value: overview.total_campaigns?.toLocaleString() || '0', color: template.accentColor },
      { label: 'Total Sent', value: overview.total_sent?.toLocaleString() || '0', color: '#ed8936' },
      { label: 'Avg CTR', value: `${overview.avg_ctr || 0}%`, color: '#e53e3e' }
    ];

    const boxWidth = 110;
    const boxHeight = 60;
    const spacing = 15;
    let xPos = 50;
    const boxY = y + 30;

    boxes.forEach((box, i) => {
      // ボックス背景
      doc.rect(xPos, boxY, boxWidth, boxHeight)
         .fillAndStroke(box.color, box.color)
         .fillOpacity(0.1);

      // 値
      doc.fillOpacity(1)
         .fillColor(box.color)
         .fontSize(20)
         .text(box.value, xPos, boxY + 15, { width: boxWidth, align: 'center' });

      // ラベル
      doc.fillColor('#666')
         .fontSize(9)
         .text(box.label, xPos, boxY + 40, { width: boxWidth, align: 'center' });

      xPos += boxWidth + spacing;
    });

    doc.moveDown(6);
  }

  // グラフセクション
  async addChartsSection(doc, stats, template) {
    const currentY = doc.y + 20;

    // 日別トレンドグラフ
    if (stats.trend.length > 0) {
      doc.fontSize(12)
         .fillColor(template.textColor)
         .text('Daily Trend', 50, currentY);

      const trendChart = await this.createTrendChart(stats.trend, template);
      doc.image(trendChart, 50, currentY + 25, { width: 495, height: 200 });

      doc.moveDown(14);
    }

    // 購読者増加グラフ
    if (stats.subscriberGrowth.length > 0) {
      const growthY = doc.y + 20;
      doc.fontSize(12)
         .fillColor(template.textColor)
         .text('Subscriber Growth', 50, growthY);

      const growthChart = await this.createGrowthChart(stats.subscriberGrowth, template);
      doc.image(growthChart, 50, growthY + 25, { width: 495, height: 150 });

      doc.moveDown(11);
    }
  }

  // トレンドグラフ作成
  async createTrendChart(data, template) {
    const canvas = createCanvas(800, 400);
    const ctx = canvas.getContext('2d');

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.map(d => d.date),
        datasets: [
          {
            label: 'Sent',
            data: data.map(d => d.sent),
            borderColor: template.primaryColor,
            backgroundColor: template.primaryColor + '1A',
            tension: 0.3,
            fill: true
          },
          {
            label: 'Clicked',
            data: data.map(d => d.clicked),
            borderColor: template.accentColor,
            backgroundColor: template.accentColor + '1A',
            tension: 0.3,
            fill: true
          }
        ]
      },
      options: {
        responsive: false,
        plugins: {
          legend: {
            display: true,
            position: 'top'
          }
        },
        scales: {
          y: {
            beginAtZero: true
          }
        }
      }
    });

    return canvas.toBuffer('image/png');
  }

  // 購読者増加グラフ作成
  async createGrowthChart(data, template) {
    const canvas = createCanvas(800, 300);
    const ctx = canvas.getContext('2d');

    new Chart(ctx, {
      type: 'bar',
      data: {
        labels: data.map(d => d.date),
        datasets: [{
          label: 'New Subscribers',
          data: data.map(d => d.new_subscribers),
          backgroundColor: template.primaryColor,
          borderRadius: 4
        }]
      },
      options: {
        responsive: false,
        plugins: {
          legend: {
            display: false
          }
        },
        scales: {
          y: {
            beginAtZero: true
          }
        }
      }
    });

    return canvas.toBuffer('image/png');
  }

  // トップキャンペーンテーブル
  addTopCampaignsTable(doc, campaigns, template) {
    if (campaigns.length === 0) return;

    const tableY = doc.y + 20;
    
    doc.fontSize(12)
       .fillColor(template.textColor)
       .text('Top Campaigns', 50, tableY);

    const tableTop = tableY + 30;
    const tableHeaders = ['Campaign', 'Date', 'Sent', 'Clicks', 'CTR'];
    const columnWidths = [200, 100, 80, 80, 75];
    let xPos = 50;

    // ヘッダー
    doc.fontSize(10)
       .fillColor('#fff');
    
    tableHeaders.forEach((header, i) => {
      doc.rect(xPos, tableTop, columnWidths[i], 25)
         .fill(template.primaryColor);
      
      doc.fillColor('#fff')
         .text(header, xPos + 5, tableTop + 8, { 
           width: columnWidths[i] - 10, 
           align: i === 0 ? 'left' : 'center' 
         });
      
      xPos += columnWidths[i];
    });

    // データ行
    let yPos = tableTop + 25;
    campaigns.slice(0, 10).forEach((campaign, rowIndex) => {
      xPos = 50;
      const bgColor = rowIndex % 2 === 0 ? '#f7fafc' : '#fff';

      doc.rect(50, yPos, 535, 25).fill(bgColor);

      const rowData = [
        campaign.name.substring(0, 30),
        new Date(campaign.created_at).toLocaleDateString('ja-JP'),
        campaign.sent?.toLocaleString() || '0',
        campaign.clicked?.toLocaleString() || '0',
        `${campaign.ctr || 0}%`
      ];

      doc.fillColor('#333')
         .fontSize(9);

      rowData.forEach((data, i) => {
        doc.text(data, xPos + 5, yPos + 8, { 
          width: columnWidths[i] - 10, 
          align: i === 0 ? 'left' : 'center' 
        });
        xPos += columnWidths[i];
      });

      yPos += 25;
    });

    doc.y = yPos + 20;
  }

  // デバイス・ブラウザ統計
  addDeviceBrowserStats(doc, devices, browsers, template) {
    const statsY = doc.y + 20;

    if (doc.y > 700) {
      doc.addPage();
      doc.y = 50;
    }

    // デバイス統計
    doc.fontSize(12)
       .fillColor(template.textColor)
       .text('Device Distribution', 50, doc.y);

    doc.moveDown(0.5);
    
    const totalDevices = devices.reduce((sum, d) => sum + parseInt(d.count), 0);
    
    devices.forEach(device => {
      const percentage = totalDevices > 0 ? ((device.count / totalDevices) * 100).toFixed(1) : 0;
      
      doc.fontSize(10)
         .fillColor('#666')
         .text(`${device.device_type || 'Unknown'}: `, 50, doc.y, { continued: true })
         .fillColor(template.textColor)
         .text(`${device.count} (${percentage}%)`);
      
      // プログレスバー
      const barWidth = (device.count / totalDevices) * 300;
      doc.rect(200, doc.y - 12, barWidth, 10)
         .fill(template.primaryColor);
      
      doc.moveDown(0.8);
    });

    doc.moveDown(1);

    // ブラウザ統計
    doc.fontSize(12)
       .fillColor(template.textColor)
       .text('Browser Distribution', 50, doc.y);

    doc.moveDown(0.5);
    
    const totalBrowsers = browsers.reduce((sum, b) => sum + parseInt(b.count), 0);
    
    browsers.forEach(browser => {
      const percentage = totalBrowsers > 0 ? ((browser.count / totalBrowsers) * 100).toFixed(1) : 0;
      
      doc.fontSize(10)
         .fillColor('#666')
         .text(`${browser.browser || 'Unknown'}: `, 50, doc.y, { continued: true })
         .fillColor(template.textColor)
         .text(`${browser.count} (${percentage}%)`);
      
      // プログレスバー
      const barWidth = (browser.count / totalBrowsers) * 300;
      doc.rect(200, doc.y - 12, barWidth, 10)
         .fill(template.accentColor);
      
      doc.moveDown(0.8);
    });
  }

  // フッター
  addFooter(doc, template) {
    const pages = doc.bufferedPageRange();
    
    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i);
      
      // ウォーターマーク（オプション）
      if (template.showWatermark) {
        doc.fontSize(8)
           .fillColor('#f0f0f0')
           .text(
             template.companyName || 'WebPush Pro',
             0,
             doc.page.height / 2,
             { align: 'center', width: doc.page.width, angle: -45 }
           );
      }
      
      // ページ番号
      doc.fontSize(9)
         .fillColor('#999')
         .text(
           `Page ${i + 1} of ${pages.count}`,
           50,
           doc.page.height - 50,
           { align: 'center', width: 495 }
         );

      // コピーライト
      doc.fontSize(8)
         .fillColor('#ccc')
         .text(
           template.footer || 'Generated by WebPush Pro',
           50,
           doc.page.height - 30,
           { align: 'center', width: 495 }
         );
    }
  }

  // カスタムテンプレート保存
  async saveCustomTemplate(siteId, template) {
    const client = await pool.connect();
    try {
      await client.query(
        'UPDATE sites SET report_template = $1 WHERE id = $2',
        [JSON.stringify(template), siteId]
      );
      return { success: true };
    } catch (error) {
      console.error('Save custom template error:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  // ロゴアップロード
  async uploadLogo(siteId, logoBuffer) {
    try {
      const logoPath = path.join(this.assetsDir, `logo_${siteId}.png`);
      fs.writeFileSync(logoPath, logoBuffer);
      
      return {
        success: true,
        logoUrl: `/assets/logo_${siteId}.png`
      };
    } catch (error) {
      console.error('Upload logo error:', error);
      throw error;
    }
  }

  // CSVレポート生成
  async generateCSVReport(siteId, startDate, endDate, reportType = 'campaigns') {
    const client = await pool.connect();
    
    try {
      let query, params;

      if (reportType === 'campaigns') {
        query = `
          SELECT 
            c.id,
            c.name,
            c.created_at,
            c.delivery_type,
            c.status,
            COUNT(d.id) FILTER (WHERE d.status = 'sent') as sent,
            COUNT(d.id) FILTER (WHERE d.status = 'clicked') as clicked,
            ROUND(
              CASE 
                WHEN COUNT(d.id) FILTER (WHERE d.status = 'sent') > 0
                THEN (COUNT(d.id) FILTER (WHERE d.status = 'clicked')::decimal / 
                      COUNT(d.id) FILTER (WHERE d.status = 'sent')) * 100
                ELSE 0
              END, 2
            ) as ctr
          FROM campaigns c
          LEFT JOIN deliveries d ON c.id = d.campaign_id
          WHERE c.site_id = $1 
            AND c.created_at BETWEEN $2 AND $3
          GROUP BY c.id
          ORDER BY c.created_at DESC
        `;
        params = [siteId, startDate, endDate];
      } else if (reportType === 'subscribers') {
        query = `
          SELECT 
            id,
            device_type,
            browser,
            os,
            subscribed_at,
            last_active_at,
            is_active
          FROM subscribers
          WHERE site_id = $1
            AND subscribed_at BETWEEN $2 AND $3
          ORDER BY subscribed_at DESC
        `;
        params = [siteId, startDate, endDate];
      }

      const result = await client.query(query, params);

      // CSV生成
      const filename = `export_${reportType}_${siteId}_${Date.now()}.csv`;
      const filepath = path.join(this.reportsDir, filename);

      const csv = this.convertToCSV(result.rows);
      fs.writeFileSync(filepath, csv, 'utf8');

      return {
        filename,
        filepath,
        url: `/api/reports/${filename}`
      };
    } catch (error) {
      console.error('Generate CSV report error:', error);
      throw error;
    } finally {
      client.release();
    }
  }

  // CSV変換
  convertToCSV(data) {
    if (data.length === 0) return '';

    const headers = Object.keys(data[0]);
    const rows = data.map(row => 
      headers.map(header => {
        const value = row[header];
        // カンマやダブルクォートを含む場合はエスケープ
        if (value && (value.toString().includes(',') || value.toString().includes('"'))) {
          return `"${value.toString().replace(/"/g, '""')}"`;
        }
        return value;
      }).join(',')
    );

    return [headers.join(','), ...rows].join('\n');
  }

  // レポートファイル削除（古いファイルのクリーンアップ）
  cleanupOldReports(daysOld = 30) {
    const files = fs.readdirSync(this.reportsDir);
    const now = Date.now();
    const maxAge = daysOld * 24 * 60 * 60 * 1000;

    files.forEach(file => {
      const filepath = path.join(this.reportsDir, file);
      const stats = fs.statSync(filepath);
      
      if (now - stats.mtimeMs > maxAge) {
        fs.unlinkSync(filepath);
        console.log(`Deleted old report: ${file}`);
      }
    });
  }
}

module.exports = new ReportService();